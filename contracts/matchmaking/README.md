# Verifiable Random Function

- ### Verifiable

Anyone can verify that the random number generated by a VRF is valid. All they need to do is inspect the proof and verify the correctness of the hash output. While only the holder of the VRF secret key can compute the hash, anyone with the public key can verify the correctness of the hash. 

- ### Random

The output of a VRF is entirely unpredictable (uniformly distributed) to anyone who doesn’t know the seed or private key and follows no pattern. In a VRF, every possible output is equally likely. The randomness is generated by combining the seed and private key in a unique manner. 

- ### Function

VRFs rely on a mathematical algorithm to produce both the random number and a proof that verifies its authenticity. For a function to be considered a VRF, the RNG must keep the seed hidden (implicit) to preserve its unpredictability, while the proof must be explicit and calculable by everyone (explicit) to ensure its verifiability. 

- ### Definition
In cryptography, a verifiable random function (VRF) is a random number generator (RNG) that generates an output that can be cryptographically verified as random. The function takes a series of inputs, computes them, and produces a pseudorandom output, along with a proof of authenticity that can be verified by anyone.

Inputs for a VRF typically include :
- A created public / private key pair.
- A selected seed. 

They're both passed into the VRF, where th private key and the seed are used to generate a random number. Then the VRF outputs a random number along with a proof. 
The generation of a proof makes the function verifiable, while keeping the private key hidden ensures the number is unpredictable.

# Empiric Network 

Empiric Network offers a verifiable randomness feed that allows protocols to request secure randomness on-chain. 

- ### How does it work?

This feed is being rolled out in two phases: In the first phase (currently live) the randomness proof is posted as calldata, allowing anyone to verify it off-chain. See below for more details on how to verify the randomness. This first phase is limited to testnet, and there is no charge for randomness.

In the second phase, the proof will be verified directly on-chain (coming soon) and requesters will be required to cover gas costs of their callback function plus a small fee to cover the cost of generating randomness.

This description come from the Empiric Network's official documentation : https://docs.empiric.network/using-empiric/randomness

# Our implementation

- Request Random Opponent :

Allows the smart-contract to request randomness from Empiric Network.
We specify an uniquely seed to determines the randomness, so Empiric as the VRF provider is
not able to manipulate the randomness. As the required private key is not know the smart-contract
is not able to predict the randomness that is calculated off-chain and sent on-chain with the proof.

- Opponent Found :

Allows the smart-contract to receive generated random word.
We use this random word received in ordre to find an opponent at each time a player want to start a fight.
The problem is that, since the random word is 251 bits, it is possible to search for a Heros with an ID that does not exist or has not yet been hit. This is not what we wanted, we want to always find an existing Hero. To be sure, we do a modulo between the random word and the total number of heroes whose fight mode is active.
After that, we can easily find the opponent, it will be the hero owner who was received at random.

- TODO : Claim Rewards